from csvlogger import CSVTradeLogger
import yfinance as yf
import pandas as pd
import numpy as np
import random
from datetime import datetime, timedelta
import json
import os
from typing import Dict, List, Optional, Tuple

class PortfolioManager:
    def __init__(self, starting_cash=100000, data_file="portfolio_data.json",
                 csv_path: str = "trading_log.csv"):
        if starting_cash < 0:
            raise ValueError("starting_cash cannot be negative")
        self.stocks = ['NVDA', 'MSFT', 'AAPL', 'JPM', 'UNH']
        self.trade_probability = 0.1
        self.shares_per_trade = 100
        if not (0 <= self.trade_probability <= 1):
            raise ValueError("trade_probability must be in [0,1]")
        if self.shares_per_trade <= 0:
            raise ValueError("shares_per_trade must be positive")
        self.data_file = data_file
        self.risk_free_rate = 0.05
        self.logger = CSVTradeLogger(csv_path, self.stocks)
        self.logger.autobackfill_on_start(default_lookback_days=365)
        if os.path.exists(data_file):
            self.load_data()
        else:
            self.portfolio = {stock: 0 for stock in self.stocks}
            self.cash = starting_cash
            self.trades = []
            self.initial_value = starting_cash
            self.daily_values = []
            self.start_date = datetime.now().date()
            self.save_data()

    def save_data(self):
        data = {
            'portfolio': self.portfolio,
            'cash': self.cash,
            'trades': self.trades,
            'initial_value': self.initial_value,
            'daily_values': self.daily_values,
            'start_date': self.start_date.isoformat() if hasattr(self,'start_date') else datetime.now().date().isoformat()
        }
        with open(self.data_file, 'w') as f:
            json.dump(data, f, indent=2, default=str)

    def load_data(self):
        with open(self.data_file, 'r') as f:
            data = json.load(f)
        self.portfolio = data['portfolio']
        self.cash = data['cash']
        self.trades = data['trades']
        self.initial_value = data['initial_value']
        self.daily_values = data.get('daily_values', [])
        self.start_date = datetime.fromisoformat(data.get('start_date', datetime.now().date().isoformat())).date()

    def get_current_prices(self) -> Dict[str, float]:
        try:
            prices = {}
            for stock in self.stocks:
                ticker = yf.Ticker(stock)
                hist = ticker.history(period='1d')
                if not hist.empty:
                    price = float(hist['Close'].iloc[-1])
                    if price <= 0:
                        raise ValueError("non-positive price")
                    prices[stock] = price
                else:
                    info = ticker.info
                    price = float(info.get('regularMarketPrice', 100))
                    if price <= 0:
                        price = 100.0
                    prices[stock] = price
            return prices
        except Exception:
            return {stock: float(random.uniform(100, 500)) for stock in self.stocks}

    def get_sp500_data(self, start_date: datetime, end_date: datetime = None) -> pd.DataFrame:
        if end_date is None:
            end_date = datetime.now()
        try:
            spy = yf.Ticker('SPY')
            return spy.history(start=start_date, end=end_date)
        except Exception:
            return pd.DataFrame()

    def snapshot_now(self, note="scheduled snapshot"):
        prices = self.get_current_prices()
        self.logger.log_now(
            prices=prices,
            action_map={},
            positions_after={t: int(self.portfolio[t]) for t in self.stocks},
            cash_after=float(self.cash),
            note=note
        )

    def simulate_trade(self) -> Optional[Dict]:
        if random.random() < self.trade_probability:
            stock_to_buy = random.choice(self.stocks)
            prices = self.get_current_prices()
            price = float(prices[stock_to_buy])
            if price <= 0:
                return None
            cost = price * self.shares_per_trade
            if self.cash >= cost:
                self.portfolio[stock_to_buy] += self.shares_per_trade
                self.cash -= cost
                trade = {
                    'timestamp': datetime.utcnow().isoformat() + "Z",
                    'stock': stock_to_buy,
                    'shares': self.shares_per_trade,
                    'price': price,
                    'total_cost': cost
                }
                self.trades.append(trade)
                self.save_data()
                action_map = {t: {"action":"NONE","quantity":0} for t in self.stocks}
                action_map[stock_to_buy] = {"action":"BUY","quantity":self.shares_per_trade}
                self.logger.log_now(
                    prices=prices,
                    action_map=action_map,
                    positions_after={t: int(self.portfolio[t]) for t in self.stocks},
                    cash_after=float(self.cash),
                    note="auto-sim trade"
                )
                return trade
            else:
                prices = self.get_current_prices()
                self.logger.log_now(
                    prices=prices,
                    action_map={},
                    positions_after={t: int(self.portfolio[t]) for t in self.stocks},
                    cash_after=float(self.cash),
                    note="insufficient-cash snapshot"
                )
        else:
            prices = self.get_current_prices()
            self.logger.log_now(
                prices=prices,
                action_map={},
                positions_after={t: int(self.portfolio[t]) for t in self.stocks},
                cash_after=float(self.cash),
                note="no-trade snapshot"
            )
        return None

    def record_daily_value(self):
        stats = self.calculate_portfolio_stats()
        today = datetime.now().date().isoformat()
        updated = False
        for record in self.daily_values:
            if record['date'] == today:
                record['value'] = stats['total_portfolio_value']
                updated = True
                break
        if not updated:
            self.daily_values.append({'date': today, 'value': stats['total_portfolio_value']})
        self.save_data()

    def calculate_portfolio_stats(self) -> Dict:
        prices = self.get_current_prices()
        stock_values = {}
        total_stock_value = 0.0
        for stock in self.stocks:
            shares = int(self.portfolio[stock])
            current_price = float(prices[stock])
            if current_price <= 0:
                current_price = 0.0
            value = shares * current_price
            stock_values[stock] = {'shares': shares, 'price': current_price, 'value': value}
            total_stock_value += value
        total_portfolio_value = total_stock_value + float(self.cash)
        total_pnl = total_portfolio_value - float(self.initial_value)
        pnl_percent = (total_pnl / float(self.initial_value)) * 100 if float(self.initial_value) > 0 else 0.0
        return {
            'stock_values': stock_values,
            'prices': prices,
            'total_stock_value': total_stock_value,
            'cash': float(self.cash),
            'total_portfolio_value': total_portfolio_value,
            'total_pnl': total_pnl,
            'pnl_percent': pnl_percent
        }

    def calculate_returns(self) -> List[float]:
        if len(self.daily_values) < 2:
            return []
        returns = []
        for i in range(1, len(self.daily_values)):
            prev_val = float(self.daily_values[i - 1]['value'])
            curr_val = float(self.daily_values[i]['value'])
            if prev_val > 0:
                returns.append((curr_val - prev_val) / prev_val)
        return returns

    def calculate_sharpe_ratio(self, returns: List[float]) -> float:
        if len(returns) < 2:
            return 0.0
        returns_array = np.array(returns, dtype=float)
        excess_returns = returns_array - (self.risk_free_rate / 252.0)
        std = float(np.std(excess_returns))
        if std == 0.0:
            return 0.0
        return float(np.mean(excess_returns) / std * np.sqrt(252.0))

    def get_sp500_returns(self) -> Tuple[List[float], float]:
        start_date = datetime.combine(self.start_date, datetime.min.time())
        sp500_data = self.get_sp500_data(start_date)
        if sp500_data.empty:
            return [], 0.0
        sp500_data['daily_return'] = sp500_data['Close'].pct_change()
        sp500_returns = sp500_data['daily_return'].dropna().astype(float).tolist()
        sp500_sharpe = self.calculate_sharpe_ratio(sp500_returns)
        return sp500_returns, sp500_sharpe

    def compare_to_sp500(self) -> Dict:
        self.record_daily_value()
        portfolio_returns = self.calculate_returns()
        portfolio_sharpe = self.calculate_sharpe_ratio(portfolio_returns)
        sp500_returns, sp500_sharpe = self.get_sp500_returns()
        portfolio_volatility = float(np.std(portfolio_returns)) * np.sqrt(252.0) if portfolio_returns else 0.0
        sp500_volatility = float(np.std(sp500_returns)) * np.sqrt(252.0) if sp500_returns else 0.0
        stats = self.calculate_portfolio_stats()
        portfolio_total_return = stats['pnl_percent'] / 100.0
        start_date = datetime.combine(self.start_date, datetime.min.time())
        sp500_data = self.get_sp500_data(start_date)
        sp500_total_return = 0.0
        if not sp500_data.empty:
            initial_sp500 = float(sp500_data['Close'].iloc[0])
            current_sp500 = float(sp500_data['Close'].iloc[-1])
            if initial_sp500 > 0:
                sp500_total_return = (current_sp500 - initial_sp500) / initial_sp500
        return {
            'portfolio': {
                'total_return': portfolio_total_return,
                'sharpe_ratio': portfolio_sharpe,
                'volatility': portfolio_volatility,
                'num_trades': len(self.trades)
            },
            'sp500': {
                'total_return': sp500_total_return,
                'sharpe_ratio': sp500_sharpe,
                'volatility': sp500_volatility
            }
        }